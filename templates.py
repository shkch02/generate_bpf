#templates.py
import textwrap

BPF_TEMPLATE = textwrap.dedent("""
#define __TARGET_ARCH_x86
#ifndef PT_REGS_PARM6
#define PT_REGS_PARM6(ctx) ((ctx)->r9)
#endif
#include <vmlinux.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>

#include "common_maps.h"
#include "common_event.h"

char LICENSE[] SEC("license") = "Dual BSD/GPL";
                    

SEC("kprobe/__x64_sys_{name}")
int trace_{name}(struct pt_regs *ctx) {{
    char comm[16];
    bpf_get_current_comm(&comm, sizeof(comm));

    // 컨테이너 런타임(runc, conmon, containerd-shim, docker)이 아니면 추적 중단
    bool is_container = false;

    // "runc"
    if (comm[0]=='r' && comm[1]=='u' && comm[2]=='n' && comm[3]=='c')
        is_container = true;

    // "conmon"
    if (comm[0]=='c' && comm[1]=='o' && comm[2]=='n' && comm[3]=='m'
        && comm[4]=='o' && comm[5]=='n')
        is_container = true;

    // "containerd-shim"
    if (comm[0]=='c' && comm[1]=='o' && comm[2]=='n' && comm[3]=='t'
        && comm[4]=='a' && comm[5]=='i' && comm[6]=='n' && comm[7]=='e'
        && comm[8]=='r' && comm[9]=='d' && comm[10]=='-' && comm[11]=='s'
        && comm[12]=='h' && comm[13]=='i' && comm[14]=='m')
        is_container = true;

    // "docker"
    if (comm[0]=='d' && comm[1]=='o' && comm[2]=='c'
        && comm[3]=='k' && comm[4]=='e' && comm[5]=='r')
        is_container = true;

    if (!is_container)
        return 0;

    /* 이하 eBPF 이벤트 생성 코드 계속… */
    struct event_t *e = bpf_ringbuf_reserve(&events, sizeof(*e), 0);
    if (!e)
        return 0;
    e->pid   = bpf_get_current_pid_tgid() >> 32;
    e->type  = EVT_{NAME};
    e->ts_ns = bpf_ktime_get_ns();
    {bindings}
    bpf_ringbuf_submit(e, 0);
    return 0;
}}
""")

MAKEFILE = textwrap.dedent("""
# Auto-generated by generate_bpf.py
BPFTOOL ?= bpftool
CC      = clang
#CFLAGS  := -O2 -g -Wall -Werror -target bpf -I. -Iinclude
LLVM_SYSROOT := $(shell $(CC) --print-resource-dir)/../..
KERNEL_SRCDIR ?= /usr/src/linux-headers-$(shell uname -r)

CFLAGS := -O2 -g -Wall -Werror -target bpf -nostdinc -isystem /usr/include -isystem $(LLVM_SYSROOT)/include -isystem $(LLVM_SYSROOT)/../lib/clang/*/include  -Iinclude -I. -I$(KERNEL_SRCDIR)/tools/lib/bpf/include
                           
# 모든 bpf 오브젝트와 스켈레톤 헤더를 빌드
TARGETS := {targets}
OBJECTS := $(addprefix bpf/,$(addsuffix _monitor.bpf.o, $(TARGETS)))
SKELETONS := $(addprefix bpf/,$(addsuffix _monitor.skel.h, $(TARGETS)))

all: $(OBJECTS) $(SKELETONS) monitor_loader
                          
# 패턴 규칙: _name_monitor.bpf.c -> _name_monitor.bpf.o
bpf/%_monitor.bpf.o: bpf/%_monitor.bpf.c include/common_event.h
	$(CC) $(CFLAGS) -Iinclude -c $< -o $@

# 패턴 규칙: .bpf.o -> .skel.h
bpf/%_monitor.skel.h: bpf/%_monitor.bpf.o
	$(BPFTOOL) gen skeleton $< > $@

monitor_loader: monitor_loader.c
	gcc -o $@ $< \
	-Iinclude \
	-I. \
	-I$(LLVM_SYSROOT)/include \
	-I$(KERNEL_SRCDIR)/tools/lib/bpf/include \
	-lbpf -lrdkafka -lpthread

clean:
	rm -f *.bpf.o *.skel.h monitor_loader
""")


# IMPROVEMENT: Kafka 관련 로직 개선 및 에러 처리 추가
#bpf 모니터링 스켈레톤 헤더들 생성위치 조정필요
LOADER_TEMPLATE = textwrap.dedent("""
                                  
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <bpf/libbpf.h>
#include <librdkafka/rdkafka.h>
#include "include/common_event_user.h"
{includes} 
// bpf 모니터링 스켈레톤 헤더들 생성위치 조정필요

static volatile bool running = true;
static rd_kafka_t *rk;
static rd_kafka_topic_t *rkt;
static const char *event_type_str[] = {{
{enum_strings}
    }};
                                           

void sig_handler(int sig) {{
    running = false;
}}

// IMPROVEMENT: Kafka delivery report callback
static void dr_msg_cb(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque) {{
    if (rkmessage->err) {{
        fprintf(stderr, " Message delivery failed: %s\\n", rd_kafka_err2str(rkmessage->err));
    }}
}}

static void kafka_init() {{
    char errstr[512];
    rd_kafka_conf_t *conf = rd_kafka_conf_new();

    if (rd_kafka_conf_set(conf, "bootstrap.servers", "localhost:9092", errstr, sizeof(errstr)) != RD_KAFKA_CONF_OK) {{
        fprintf(stderr, "%s\\n", errstr);
        exit(1);
    }}
    // Set delivery report callback
    rd_kafka_conf_set_dr_msg_cb(conf, dr_msg_cb);

    rk = rd_kafka_new(RD_KAFKA_PRODUCER, conf, errstr, sizeof(errstr));
    if (!rk) {{
        fprintf(stderr, "Failed to create new producer: %s\\n", errstr);
        exit(1);
    }}
    rkt = rd_kafka_topic_new(rk, "syscall_events", NULL);
}}

static void kafka_send(const char* buffer, size_t len) {{
    if (!buffer || len == 0) return;
    // RD_KAFKA_MSG_F_COPY makes a copy of the payload.
    rd_kafka_produce(rkt, RD_KAFKA_PARTITION_UA, RD_KAFKA_MSG_F_COPY, (void*)buffer, len, NULL, 0, NULL);
    // Poll for delivery reports (and other events).
    rd_kafka_poll(rk, 0);
}}

// IMPROVEMENT: Robust JSON serialization for each event type
static void serialize_and_send(const struct event_t *e) {{
    char *buf = NULL;
    size_t size = 0;
    FILE *f = open_memstream(&buf, &size);
    if (!f) return;

    fprintf(f, "{{\\"type\\":\\"%s\\",\\"pid\\":%u,\\"ts\\":%llu", event_type_str[e->type], e->pid, e->ts_ns);

    // Event-specific data
    switch (e->type) {{
{event_cases}
    default:
        break;
    }}

    fprintf(f, "}}");
    fclose(f);

    kafka_send(buf, size);
    free(buf);
}}

static int on_event(void *ctx, void *data, size_t size) {{
    serialize_and_send((const struct event_t *)data);
    return 0;
}}

int main() {{
    signal(SIGINT, sig_handler);
    signal(SIGTERM, sig_handler);

    kafka_init();

    {skeletons}
    {attaches}

    int map_fd = bpf_map__fd({first}_skel->maps.events);
    struct ring_buffer *rb = ring_buffer__new(map_fd, on_event, NULL, NULL);
    if (!rb) {{
        fprintf(stderr, "Failed to create ring buffer\\n");
        goto cleanup;
    }}

    printf("Monitoring syscalls... Press Ctrl+C to exit.\\n\\n");
    while (running) {{
        if (ring_buffer__poll(rb, 100) < 0) {{
            fprintf(stderr, "Error polling ring buffer\\n");
            break;
        }}
        // Poll Kafka regularly to serve delivery reports and other callbacks.
        rd_kafka_poll(rk, 0);
    }}

cleanup:
    ring_buffer__free(rb);
    {destroys}
    fprintf(stderr, "\\nFlushing final Kafka messages...\\n");
    rd_kafka_flush(rk, 10 * 1000); // Wait for max 10 seconds
    rd_kafka_topic_destroy(rkt);
    rd_kafka_destroy(rk);
    printf("Cleaned up resources.\\n");
    return 0;
}}
""")

BPF_HEADER = textwrap.dedent("""
#pragma once
#include <vmlinux.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>                      
                    
                             
    // IMPROVEMENT: Increased max string length for paths, etc.
    // This is a hard limit; longer strings will be truncated.
    #define MAX_STR_LEN 1024

enum event_type {{
    {enum_entries}
        EVT_MAX,
    }};

    
{struct_definitions}

struct event_t {{
        __u32 pid;
        enum event_type type;
        __u64 ts_ns;
        union {{
    {union_entries}
        }} data;
    }};
    """)

USER_HEADER = textwrap.dedent("""
#pragma once

/* 1) 필수 헤더 */
#include <stdint.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <linux/keyctl.h>
#include <sys/capability.h>
#include <aio.h>
#include <mqueue.h>

/* 2) 축약형 정수 타입 */
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint16_t u16;
typedef uint8_t  u8;
typedef  int64_t s64;
typedef  int32_t s32;
typedef  int16_t s16;
typedef   int8_t s8;

/* 3) uapi 헤더에 없는, 커널 전용 타입 매핑 */
/*    이미 정의된 표준 타입은 건드리지 않습니다. */
#ifndef umode_t
typedef mode_t             umode_t;           /* 파일 모드 */
#endif

#ifndef __kernel_dev_t
typedef dev_t              __kernel_dev_t;    /* 커널 dev_t */
#endif

#ifndef __kernel_loff_t
typedef long long          __kernel_loff_t;
#endif

#ifndef __kernel_time64_t
typedef long long          __kernel_time64_t;
#endif

#ifndef __kernel_clockid_t
typedef int                __kernel_clockid_t;
#endif

#ifndef __kernel_timer_t
typedef int                __kernel_timer_t;
#endif

#ifndef __kernel_uid32_t
typedef uid_t              __kernel_uid32_t;
#endif

#ifndef __kernel_gid32_t
typedef gid_t              __kernel_gid32_t;
#endif

#ifndef __kernel_size_t
typedef size_t             __kernel_size_t;
#endif

#ifndef __kernel_ssize_t
typedef ssize_t            __kernel_ssize_t;
#endif

#ifndef __kernel_pid_t
typedef pid_t              __kernel_pid_t;
#endif

#ifndef key_serial_t
typedef int                key_serial_t;
#endif

#ifndef aio_context_t
typedef unsigned long      aio_context_t;
#endif
   
                    
                             
    // IMPROVEMENT: Increased max string length for paths, etc.
    // This is a hard limit; longer strings will be truncated.
    #define MAX_STR_LEN 1024

    enum event_type {{
    {enum_entries}
        EVT_MAX,
    }};

    
    {struct_definitions}

    struct event_t {{
        __u32 pid;
        enum event_type type;
        __u64 ts_ns;
        union {{
    {union_entries}
        }} data;
    }};
    """)

STRUCT_TMPL = textwrap.dedent("""
    struct {name}_event_t {{
    {fields}
    }};
""")
